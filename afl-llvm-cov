#!/usr/bin/env python3
#
#  File: afl-llvm-cov
#
#  Version: 0.7.0
#
#  Purpose: Perform lcov coverage diff's against each AFL queue file to see
#           new functions and line coverage evolve from an AFL fuzzing cycle.
#
#  Copyright (C) 2015-2016 Michael Rash (mbr@cipherdyne.org)
#  Copyright (C) 2018-2021 Marc "vanHauser" Heuse (mh@mh-sec.de)
#
#  License (GNU General Public License version 2 or any later version):
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02111-1301,
#  USA
#
import argparse
import errno
import glob
import os
import re
import signal
import sys
import time
from shutil import rmtree
from shutil import copyfile
from sys import argv
from tempfile import NamedTemporaryFile
from typing import Any, Dict, Iterator, List, Union, Optional, Tuple

try:
    import subprocess32 as subprocess
except ImportError:
    import subprocess

__version__ = "0.7.0"

NO_OUTPUT = 0
WANT_OUTPUT = 1
LOG_ERRORS = 2

# id_min id_max are int, dirs is Dict, the rest is str or dict.
CovPathsDictType = Dict[str, Union[Dict[str, str], str, int]]
CovDictType = Dict[bytes, Dict[bytes, Dict[bytes, Dict[bytes, bytes]]]]


def main():
    exit_success = 0
    exit_failure = 1

    cargs = parse_cmdline()
    
    if cargs.coverage_cmd:
        cargs.coverage_cmd = cargs.coverage_cmd.replace("@@", "AFL_FILE")

    if cargs.version:
        print("afl-llvm-cov-" + __version__)
        return exit_success

    if cargs.llvm_cov_check_bin:
        if is_cov_enabled(cargs):
            return exit_success
        else:
            return exit_failure

    if not check_requirements(cargs):
        return exit_failure

    if cargs.stop_afl:
        return not stop_afl(cargs)

    if not validate_cargs(cargs):
        return exit_failure

    if cargs.validate_args:
        return exit_success

    if cargs.background:
        run_in_background()

    if cargs.live:
        is_afl_running(cargs)

    return not process_afl_test_cases(cargs)


# noinspection PyUnresolvedReferences
def run_in_background() -> None:
    # could use the python 'daemon' module, but it isn't always
    # installed, and we just need a basic backgrounding
    # capability anyway
    pid = os.fork()
    if pid < 0:
        print("[*] fork() error, exiting.")
        os._exit(1)
    elif pid > 0:
        os._exit(0)
    else:
        os.setsid()


def process_afl_test_cases(cargs: argparse.Namespace) -> bool:
    rv = True
    run_once = False
    tot_files = 0
    curr_cycle = -1

    afl_files = set()  # type: Set[str]
    cov_paths = {}  # type: CovPathsDictType

    # main coverage tracking dictionary
    cov = {
        b"zero": {},
        b"pos": {},
    }  # type: CovDictType

    while True:

        new_files = []

        if not import_fuzzing_dirs(cov_paths, cargs):
            rv = False
            break

        dir_ctr = 0
        last_dir = False

        do_coverage = True
        if cargs.cover_corpus:
            do_coverage = False

        for fuzz_dir in cov_paths["dirs"]:

            do_break = False
            last_file = False
            num_files = 0
            tmp_files = import_test_cases(fuzz_dir + "/queue")  # type: Iterator[str]
            dir_ctr += 1
            f_ctr = 0

            if dir_ctr == len(cov_paths["dirs"]):
                last_dir = True

            for f in tmp_files:
                if f not in afl_files:
                    afl_files.add(f)
                    new_files.append(f)

            if new_files:
                logr(
                    b"\n*** Imported %d new test cases from: %s\n"
                    % (len(new_files), (fuzz_dir + "/queue").encode()),
                    cov_paths["log_file"],
                    cargs,
                )

            for f in new_files:

                f_ctr += 1
                if f_ctr == len(new_files):
                    last_file = True


                if cargs.afl_file:
                    try:
                        copyfile(f, cargs.afl_file)
                    except Exception:
                        print("[-] Cannot copy file")
                        sys.exit(1)
 
                if cargs.cover_corpus and last_dir and last_file:
                    # in --cover-corpus mode, only run lcov after all AFL
                    # test cases have been processed
                    do_coverage = True

                out_lines = []  # type: List[bytes]
                curr_cycle = get_cycle_num(num_files, cargs)

                logr(
                    b"[+] AFL test case: %s (%d / %d), cycle: %d"
                    % (
                        os.path.basename(f).encode(errors="namereplace"),
                        num_files,
                        len(new_files),
                        curr_cycle,
                    ),
                    cov_paths["log_file"],
                    cargs,
                )

                id_range_update(f, cov_paths)
                
                cov_replace = cargs.coverage_cmd.replace("AFL_FILE", f)
                llvm_profile_dir = os.path.realpath(cov_paths["profdata_dir"])
                cov_cmd = f"LLVM_PROFILE_FILE=\"{llvm_profile_dir}/{os.path.basename(f)}.profraw\" {cov_replace}"

                # execute the command to generate code coverage stats
                # for the current AFL test case file
                if run_once:
                    run_cmd(
                        cov_cmd,
                        cov_paths["log_file"],
                        cargs,
                        NO_OUTPUT,
                        True,
                        f,
                        cargs.timeout,
                    )
                else:
                    out_lines = run_cmd(
                        cov_cmd,
                        cov_paths["log_file"],
                        cargs,
                        WANT_OUTPUT,
                        True,
                        f,
                        cargs.timeout,
                    )[1]
                    run_once = True

                if (
                    cargs.afl_queue_id_limit
                    and num_files >= cargs.afl_queue_id_limit - 1
                ):
                    logr(
                        b"[+] queue/ id limit of %d reached..."
                        % cargs.afl_queue_id_limit,
                        cov_paths["log_file"],
                        cargs,
                    )
                    do_break = True
                    if cargs.cover_corpus and last_dir:
                        do_coverage = True

                if do_coverage:
                    if cargs.cover_corpus:
                        # reset the range values
                        cov_paths["id_min"] = cov_paths["id_max"] = -1

                    # log the output of the very first coverage command to
                    # assist in troubleshooting
                    if len(out_lines):
                        logr(
                            b"\n\n++++++ BEGIN - first exec output for CMD: %s"
                            % (cargs.coverage_cmd.replace("AFL_FILE", f).encode()),
                            cov_paths["log_file"],
                            cargs,
                        )
                        for line in out_lines:
                            logr(b"    %s" % line, cov_paths["log_file"], cargs)
                        logr(b"++++++ END\n", cov_paths["log_file"], cargs)

                cov_paths["id_file"] = "%s" % os.path.basename(f)

                num_files += 1
                tot_files += 1

                if do_break:
                    break

            new_files = []

        if cargs.live:
            if is_afl_fuzz_running(cargs):
                if not len(new_files):
                    logr(
                        b"[-] No new AFL test cases, sleeping for %d seconds"
                        % cargs.sleep,
                        cov_paths["log_file"],
                        cargs,
                    )
                    try:
                        time.sleep(cargs.sleep)
                    except KeyboardInterrupt:
                        logr(
                            b"[!] Stopping live collection due to user interrupt",
                            cov_paths["log_file"],
                            cargs,
                        )
                        break
                    continue
            else:
                logr(
                    b"[+] afl-fuzz appears to be stopped...",
                    cov_paths["log_file"],
                    cargs,
                )
                break
        # only go once through the loop unless we are in --live mode
        else:
            break

    if tot_files > 0:
        logr(
            b"[+] Processed %d / %d test cases.\n" % (tot_files, len(afl_files)),
            cov_paths["log_file"],
            cargs,
        )

        llvm_cov_gen_coverage(cov_paths, cargs)

        # write out the final zero coverage and positive coverage reports
        # write_zero_cov(cov[b"zero"], cov_paths, cargs)
        # write_pos_cov(cov[b"pos"], cov_paths, cargs)
    else:
        if rv:
            logr(
                b"[*] Did not find any AFL test cases, exiting.\n",
                cov_paths["log_file"],
                cargs,
            )
        rv = False

    return rv


def id_range_update(afl_file: str, cov_paths: CovPathsDictType) -> None:
    id_val = int(os.path.basename(afl_file).split(",")[0].split(":")[1])

    if cov_paths["id_min"] == -1:
        cov_paths["id_min"] = id_val
    elif id_val < cov_paths["id_min"]:
        cov_paths["id_min"] = id_val

    if cov_paths["id_max"] == -1:
        cov_paths["id_max"] = id_val
    elif id_val > cov_paths["id_max"]:
        cov_paths["id_max"] = id_val


def write_zero_cov(
    zero_cov: CovDictType, cov_paths: CovPathsDictType, cargs: argparse.Namespace
) -> None:
    cpath = cov_paths["zero_cov"]

    logr(
        b"[+] Final zero coverage report: %s" % cpath.encode(),
        cov_paths["log_file"],
        cargs,
    )
    cfile = open(cpath, "wb")
    cfile.write(b"# All functions / lines in this file were never executed by any\n")
    cfile.write(b"# AFL test case.\n")
    cfile.close()
    write_cov(cpath, zero_cov, cargs)


def write_pos_cov(
    pos_cov: CovDictType, cov_paths: CovPathsDictType, cargs: argparse.Namespace
) -> None:
    cpath = cov_paths["pos_cov"]

    logr(
        b"[+] Final positive coverage report: %s" % cpath.encode(),
        cov_paths["log_file"],
        cargs,
    )
    cfile = open(cpath, "wb")
    cfile.write(b"# All functions / lines in this file were executed by at\n")
    cfile.write(b"# least one AFL test case. See the cov/id-delta-cov file\n")
    cfile.write(b"# for more information.\n")
    cfile.close()
    write_cov(cpath, pos_cov, cargs)


def write_cov(cpath: str, cov: CovDictType, cargs: argparse.Namespace) -> None:
    cfile = open(cpath, "ab")
    for f in cov:
        cfile.write(b"File: %s\n" % f)
        for ctype in sorted(cov[f]):
            if ctype == b"function":
                for val in sorted(cov[f][ctype]):
                    cfile.write(b"    %s: %s\n" % (ctype, val))
            elif ctype == b"line":
                if cargs.coverage_include_lines:
                    for val in sorted(cov[f][ctype], key=int):
                        cfile.write(b"    %s: %s\n" % (ctype, val))
    cfile.close()


def write_status(status_file: str) -> None:
    f = open(status_file, "wb")
    f.write(b"afl_cov_pid     : %d\n" % os.getpid())
    f.write(b"afl_cov_version : %s\n" % __version__.encode())
    f.write(b"command_line    : %s\n" % " ".join(argv).encode())
    f.close()


def append_file(pstr: bytes, path: str) -> None:
    f = open(path, "ab")
    f.write(b"%s\n" % pstr)
    f.close()

def get_cycle_num(id_num: int, cargs: argparse.Namespace) -> int:
    # default cycle
    cycle_num = 0

    if not is_dir(cargs.afl_fuzzing_dir + "/plot_data"):
        return cycle_num

    with open(cargs.afl_fuzzing_dir + "/plot_data") as f:
        for line in f:
            # unix_time, cycles_done, cur_path, paths_total, pending_total,...
            # 1427742641, 11, 54, 419, 45, 0, 2.70%, 0, 0, 9, 1645.47
            vals = line.split(", ")
            # test the id number against the current path
            if vals[2] == str(id_num):
                cycle_num = int(vals[1])
                break

    return cycle_num

def llvm_cov_gen_coverage(cov_paths: CovPathsDictType, cargs: argparse.Namespace):
    llvm_profdata_merge_opts = "llvm-profdata merge"
    
    profdata_files = sorted(glob.glob(cov_paths["profdata_dir"] + "/*.profraw"))
    for f in profdata_files:
        llvm_profdata_merge_opts += " %s" % (os.path.realpath(f))
        
    llvm_profdata_merged_file = "%s/merged.profdata" % cov_paths["profdata_dir"]
    llvm_profdata_merge_opts += f" -o {llvm_profdata_merged_file}"
    run_cmd(llvm_profdata_merge_opts, 
            cov_paths["log_file"], 
            cargs, 
            LOG_ERRORS, 
            False, 
            ""
            )
    
    llvm_show_opts = "llvm-cov show --format=html"
    
    if cargs.enable_branch_coverage:
        llvm_show_opts += " --show-branches=count --show-expansions"
    
    llvm_profdata_html_file = "%s/index.html" % cov_paths["top_dir"]
    llvm_show_opts += f" -instr-profile={llvm_profdata_merged_file} -object {os.path.realpath(cargs.test_object)} >> {os.path.realpath(llvm_profdata_html_file)}"
    
    run_cmd(llvm_show_opts, 
            cov_paths["log_file"], 
            cargs, 
            LOG_ERRORS, 
            False, 
            ""
            )
    
    return


def is_afl_fuzz_running(cargs):
    pid = None
    stats_file = cargs.afl_fuzzing_dir + "/fuzzer_stats"

    if os.path.exists(stats_file):
        pid = get_running_pid(stats_file, rb"fuzzer_pid\s+\:\s+(\d+)")
    else:
        for p in os.listdir(cargs.afl_fuzzing_dir):
            #stats_file = "%s/%s/fuzzer_stats" % (
            #    cargs.afl_fuzzing_dir.encode(),
            #    p.encode(),
            #)
            stats_file = "%s/%s/fuzzer_stats" % ( cargs.afl_fuzzing_dir, p)
            if os.path.exists(stats_file):
                # allow a single running AFL instance in parallel mode
                # to mean that AFL is running (and may be generating
                # new code coverage)
                pid = get_running_pid(stats_file, rb"fuzzer_pid\s+\:\s+(\d+)")
                if pid:
                    break

    return pid


def get_running_pid(stats_file: str, pid_re: bytes) -> Optional[int]:
    pid = None
    if not os.path.exists(stats_file):
        return pid
    with open(stats_file, "rb") as f:
        for line in f:
            line = line.strip()
            # fuzzer_pid     : 13238
            m = re.search(pid_re, line)
            if m and m.group(1):
                is_running = int(m.group(1))
                try:
                    os.kill(is_running, 0)
                except OSError as e:
                    if e.errno == errno.EPERM:
                        pid = is_running
                else:
                    pid = is_running
                break
    return pid


def run_cmd(
    cmd: str,
    log_file: Optional[str],
    cargs: argparse.Namespace,
    collect: int,
    aflrun: bool,
    fn: str,
    timeout: Optional[int] = None,
) -> Tuple[int, List[bytes]]:
    out = []

    if cargs.disable_cmd_redirection or collect == WANT_OUTPUT or collect == LOG_ERRORS:
        fh = NamedTemporaryFile(delete=False)
    else:
        fh = open(os.devnull, "wb")

    if timeout:
        # timeout_pipe = "|" if cargs.llvm_config_path else ""
        cmd = "timeout -s KILL %s | %s" % (timeout, cmd)

    if aflrun is True and len(fn) > 0:
        cmd = "cat " + fn + " | " + cmd

    if cargs.verbose:
        if log_file:
            logr(b"    CMD: %s" % cmd.encode(errors="namereplace"), log_file, cargs)
        else:
            print("    CMD: %s" % cmd)

    exit_code = subprocess.call(
        cmd, stdin=None, stdout=fh, stderr=subprocess.STDOUT, shell=True
    )

    fh.close()

    if cargs.disable_cmd_redirection or collect == WANT_OUTPUT or collect == LOG_ERRORS:
        with open(fh.name, "rb") as f:
            for line in f:
                out.append(line.rstrip(b"\n"))
        os.unlink(fh.name)

    if (exit_code != 0) and (
        collect == LOG_ERRORS or (collect == WANT_OUTPUT and cargs.verbose)
    ):
        if log_file:
            logr(
                b"    Non-zero exit status '%d' for CMD: %s"
                % (exit_code, cmd.encode()),
                log_file,
                cargs,
            )
            for line in out:
                logr(b"    " + line, log_file, cargs)
        else:
            print("    Non-zero exit status '%d' for CMD: %s" % (exit_code, cmd))

    return exit_code, out


def import_fuzzing_dirs(cov_paths: CovPathsDictType, cargs: argparse.Namespace) -> bool:
    if not cargs.afl_fuzzing_dir:
        print("[*] Must specify AFL fuzzing dir with --afl-fuzzing-dir or -d")
        return False

    if "top_dir" not in cov_paths:
        if not init_tracking(cov_paths, cargs):
            return False

    def_dir = cargs.afl_fuzzing_dir

    if is_dir("%s/queue" % def_dir):
        if def_dir not in cov_paths["dirs"]:
            add_dir(def_dir, cov_paths)
    else:
        for p in os.listdir(def_dir):
            fuzz_dir = "%s/%s" % (def_dir, p)
            if is_dir(fuzz_dir):
                if is_dir("%s/queue" % fuzz_dir):
                    # found an AFL fuzzing directory instance from
                    # parallel AFL execution
                    if fuzz_dir not in cov_paths["dirs"]:
                        add_dir(fuzz_dir, cov_paths)

    return True


def import_test_cases(qdir: str) -> Iterator[str]:
    return sorted(glob.glob(qdir + "/id:*"))


def init_tracking(cov_paths: CovPathsDictType, cargs: argparse.Namespace) -> bool:
    cov_paths["dirs"] = {}

    cov_paths["top_dir"] = "%s/cov" % cargs.afl_fuzzing_dir
    cov_paths["profdata_dir"] = "%s/profdata" % cov_paths["top_dir"]
    cov_paths["log_file"] = "%s/afl-cov.log" % cov_paths["top_dir"]

    # global coverage results
    cov_paths["zero_cov"] = "%s/zero-cov" % cov_paths["top_dir"]
    cov_paths["pos_cov"] = "%s/pos-cov" % cov_paths["top_dir"]
    cov_paths["id_file"] = ""
    cov_paths["id_min"] = -1  # used in --cover-corpus mode
    cov_paths["id_max"] = -1  # used in --cover-corpus mode

    if cargs.overwrite:
        mkdirs(cov_paths, cargs)

    write_status("%s/afl-cov-status" % cov_paths["top_dir"])

    return True


# credit:
# http://stackoverflow.com/questions/377017/test-if-executable-exists-in-python
def is_exe(fpath: str) -> bool:
    return os.path.isfile(fpath) and os.access(fpath, os.X_OK)


def is_bin_llvm_prof_enabled(binary: str, cargs: argparse.Namespace) -> bool:
    rv = False

    # run readelf against the binary to see if it contains gcov support
    for line in run_cmd(
        "%s -a %s" % (cargs.readelf_path, binary), None, cargs, WANT_OUTPUT, False, ""
    )[1]:
        if b" __llvm_prf_names" in line:
            if cargs.validate_args or cargs.llvm_cov_check_bin:
                print(
                    "[+] Binary '%s' is compiled with code coverage support via clang."
                    % binary
                )
            rv = True
            break

    if not rv and cargs.llvm_cov_check_bin:
        print("[*] Binary '%s' is not compiled with code coverage support." % binary)

    return rv


def which(prog: str) -> Optional[str]:
    fpath, fname = os.path.split(prog)
    if fpath:
        if is_exe(prog):
            return prog
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            path = path.strip('"')
            exe_file = os.path.join(path, prog)
            if is_exe(exe_file):
                return exe_file
    return None


def check_requirements(cargs: argparse.Namespace) -> bool:
    llvm_cov = which("llvm-cov")
    llvm_profdata = which("llvm-profdata")
    
    if llvm_cov is None or llvm_profdata is None:
        print("Required command not found :")
    else:
        return True

    if llvm_cov is None:
        print("[*] llvm-cov command does not exist :", cargs.llvm_config_path)
    if llvm_profdata is None:
        print("[*] llvm_profdata command does not exist :", cargs.llvm_config_path)

    return False


def is_cov_enabled(cargs: argparse.Namespace) -> bool:
    if not is_exe(cargs.readelf_path):
        print("[*] Need a valid path to readelf, use --readelf-path")
        return False

    if cargs.coverage_cmd:
        # make sure at least one component of the command is an
        # executable and is compiled with code coverage support

        found_exec = False
        found_code_cov_binary = False

        for part in cargs.coverage_cmd.split(" "):
            if not part or part[0] == " " or part[0] == "-":
                continue
            if which(part):
                found_exec = True
                if not cargs.disable_llvm_cov_check and is_bin_llvm_prof_enabled(cargs.test_object, cargs):
                    found_code_cov_binary = True
                    break

        if not found_exec:
            print(
                "[*] Could not find an executable binary "
                "--coverage-cmd '%s'" % cargs.coverage_cmd
            )
            return False

        if not cargs.disable_llvm_cov_check and not found_code_cov_binary:
            print(
                "[*] Could not find an executable binary with code "
                "coverage support ('-fprofile-instr-generate -fcoverage-mapping') "
                "in --coverage-cmd '%s'" % cargs.coverage_cmd
            )
            return False

    elif cargs.llvm_cov_check_bin:
        if not is_bin_llvm_prof_enabled(cargs.llvm_cov_check_bin, cargs):
            return False

    return True


def validate_cargs(cargs: argparse.Namespace) -> bool:
    if cargs.coverage_cmd:
        if not is_cov_enabled(cargs):
            return False

    if cargs.code_dir:
        if not is_dir(cargs.code_dir):
            print("[*] --code-dir path does not exist")
            return False

    #if cargs.live and not cargs.ignore_core_pattern:
    #    if not check_core_pattern():
    #        return False

    if not cargs.live and not is_dir(cargs.afl_fuzzing_dir):
        print(
            "[*] It doesn't look like directory '%s' exists" % (cargs.afl_fuzzing_dir)
        )
        return False

    return True


def is_afl_running(cargs: argparse.Namespace) -> bool:
    while not is_dir(cargs.afl_fuzzing_dir):
        if not cargs.background:
            print(
                "[-] Sleep for %d seconds for AFL fuzzing directory to be created..."
                % cargs.sleep
            )
        time.sleep(cargs.sleep)

    # if we make it here then afl-fuzz is presumably running
    while not is_afl_fuzz_running(cargs):
        if not cargs.background:
            print(
                "[-] Sleep for %d seconds waiting for afl-fuzz to be started...."
                % cargs.sleep
            )
        time.sleep(cargs.sleep)
    return


def add_dir(fdir: str, cov_paths: Dict[str, Union[Dict[str, Any], bytes]]) -> None:
    cov_paths["dirs"][fdir] = {}


def mkdirs(cov_paths: CovPathsDictType, cargs: argparse.Namespace) -> None:
    create_cov_dirs = False
    if is_dir(cov_paths["top_dir"]):
        if cargs.overwrite:
            rmtree(cov_paths["top_dir"])
            create_cov_dirs = True
    else:
        create_cov_dirs = True

    if create_cov_dirs:
        for k in ["top_dir", "profdata_dir"]:
            if not is_dir(cov_paths[k]):
                os.mkdir(cov_paths[k])

def is_dir(dpath: str) -> bool:
    return os.path.exists(dpath) and os.path.isdir(dpath)


def logr(pstr: bytes, log_file: str, cargs: argparse.Namespace) -> None:
    if not cargs.background and not cargs.quiet:
        sys.stdout.buffer.write(b"    %s\n" % pstr)
    append_file(pstr, log_file)


def stop_afl(cargs: argparse.Namespace) -> bool:
    rv = True

    # note that this function only looks for afl-fuzz processes - it does not
    # stop afl-cov processes since they will stop on their own after afl-fuzz
    # is also stopped.

    if not cargs.afl_fuzzing_dir:
        print("[*] Must set --afl-fuzzing-dir")
        return False

    if not is_dir(cargs.afl_fuzzing_dir):
        print(
            "[*] Doesn't look like AFL fuzzing directory '%s' exists."
            % cargs.afl_fuzzing_dir
        )
        return False

    if os.path.exists(cargs.afl_fuzzing_dir + "/fuzzer_stats"):
        afl_pid = get_running_pid(
            cargs.afl_fuzzing_dir + "/fuzzer_stats", rb"fuzzer_pid\s+\:\s+(\d+)"
        )
        if afl_pid:
            print("[+] Stopping running afl-fuzz instance, PID: %d" % afl_pid)
            os.kill(afl_pid, signal.SIGTERM)
        else:
            print("[-] No running afl-fuzz instance")
            rv = False
    else:
        found = False
        for p in os.listdir(cargs.afl_fuzzing_dir):
            stats_file = cargs.afl_fuzzing_dir + "/" + p + "/fuzzer_stats"
            if os.path.exists(stats_file):
                afl_pid = get_running_pid(stats_file, rb"fuzzer_pid\s+\:\s+(\d+)")
                if afl_pid:
                    print("[+] Stopping running afl-fuzz instance, PID: %d" % afl_pid)
                    os.kill(afl_pid, signal.SIGTERM)
                    found = True
        if not found:
            print("[-] No running afl-fuzz instance")
            rv = False

    return rv


#def check_core_pattern() -> bool:
#    rv = True
#
#    core_pattern_file = "/proc/sys/kernel/core_pattern"
#
#    # check /proc/sys/kernel/core_pattern to see if afl-fuzz will
#    # accept it
#    if os.path.exists(core_pattern_file):
#        with open(core_pattern_file, "rb") as f:
#            if f.readline().rstrip()[0] == b"|":
#                # same logic as implemented by afl-fuzz itself
#                print("[*] afl-fuzz requires 'echo core >%s'" % core_pattern_file)
#                rv = False
#    return rv


def parse_cmdline() -> argparse.Namespace:
    p = argparse.ArgumentParser()

    p.add_argument(
        "-e",
        "--coverage-cmd",
        type=str,
        help="Set command to exec (including args, and assumes code coverage support)",
    )
    p.add_argument(
        "--test-object",
        type=str,
        help="Name of the target binary (need or llvm-cov show command)",
    )
    p.add_argument(
        "-d", "--afl-fuzzing-dir", type=str, help="top level AFL fuzzing directory"
    )
    p.add_argument(
        "-c",
        "--code-dir",
        type=str,
        help="Directory where the code lives (compiled with code coverage support)",
    )
    p.add_argument(
        "-O",
        "--overwrite",
        action="store_true",
        help="Overwrite existing coverage results",
        default=False,
    )
    p.add_argument(
        "--disable-cmd-redirection",
        action="store_true",
        help="Disable redirection of command results to /dev/null",
        default=False,
    )
    p.add_argument(
        "--disable-coverage-init",
        action="store_true",
        help="Disable initialization of code coverage counters at afl-cov startup",
        default=False,
    )
    p.add_argument(
        "--enable-branch-coverage",
        action="store_true",
        help="Include branch coverage in code coverage reports (may be slow)",
        default=False,
    )
    p.add_argument(
        "--live",
        action="store_true",
        help="Process a live AFL directory, and afl-cov will exit when it appears afl-fuzz has been stopped",
        default=False,
    )
    p.add_argument(
        "--cover-corpus",
        action="store_true",
        help="Measure coverage after running all available tests instead of individually per queue file",
        default=False,
    )
    p.add_argument(
        "--sleep",
        type=int,
        help="In --live mode, # of seconds to sleep between checking for new queue files",
        default=60,
    )
    p.add_argument(
        "--llvm-cov-check-bin",
        type=str,
        help="Test a specific binary for clang code coverage support",
        default=False,
    )
    p.add_argument(
        "--disable-llvm-cov-check",
        type=str,
        help="Disable check for clang code coverage support",
        default=False,
    )
    p.add_argument(
        "--background",
        action="store_true",
        help="Background mode - if also in --live mode, will exit when the alf-fuzz process is finished",
        default=False,
    )
    p.add_argument(
        "--afl-queue-id-limit",
        type=int,
        help="Limit the number of id:NNNNNN* files processed in the AFL queue/ directory",
        default=0,
    )
    p.add_argument(
        "--ignore-core-pattern",
        action="store_true",
        help="Ignore the /proc/sys/kernel/core_pattern setting in --live mode",
        default=False,
    )
    p.add_argument(
        "--llvm-config-path",
        type=str,
        help="Path to llvm-config command",
        default="/usr/local/bin",
    )
    p.add_argument(
        "--readelf-path",
        type=str,
        help="Path to readelf command",
        default="/usr/bin/readelf",
    )
    p.add_argument(
        "--stop-afl",
        action="store_true",
        help="Stop all running afl-fuzz instances associated with --afl-fuzzing-dir <dir>",
        default=False,
    )
    p.add_argument(
        "--validate-args",
        action="store_true",
        help="Validate args and exit",
        default=False,
    )
    p.add_argument(
        "-v", "--verbose", action="store_true", help="Verbose mode", default=False
    )
    p.add_argument(
        "-V",
        "--version",
        action="store_true",
        help="Print version and exit",
        default=False,
    )
    p.add_argument(
        "-q", "--quiet", action="store_true", help="Quiet mode", default=False
    )
    p.add_argument(
        "-T", "--timeout", type=str, help="timeout (default 5 seconds)", default="5"
    )
    p.add_argument(
        "--afl-file", type=str, help="Filepath that is passed to AFL with -f argument", default=""
    )

    return p.parse_args()


if __name__ == "__main__":
    sys.exit(main())
